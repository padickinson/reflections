Q: What happens when you initialize a repository? Why do you need to do it?
A: Create a .git directory to store the repository data
Q: How is the staging area different from the working directory and the repository? What value do you think it offers?
A: Staging provides a way to specify which set of changes should be grouped together for a commit. This makes it easier to break up commits logically.
Q: How can you use the staging area to make sure you have one commit per logical change?
A: By using git diff, git diff --staged, and git diff <commit old> <commit new>, we can see all the changes between working dir, staging area, most recent commit, other commits. By using git add we can add changes to the staging area to make up a logical unit for committing.
Q: What are some situations when branches would be helpful in keeping your history organized? How would branches help?
A: Branches are useful for working on changes / refactors / features etc. that are more complex than a single commit, and which are not ready to be merged into the main (master) branch
Q: How do the diagrams help you visualize the branch structure?
A: Using diagrams generated by git log --graph --oneline <branch1> ... <branch n> allows me to see which commits are reachable from each bracnh, and how much difference there is between branches.
Q:What is the result of merging two branches together? Why do we represent it in the diagram the way we do?
A: Merging branches combines branches, providing a new tip. The git log for the new tip shows all the commits on both branches, in timestamp order.  git show <commit> shows changes compared to parent. git merge <branch> mergees branch into current. git branch -d <branch> deletes the branch
Q: What are the pros and cons of Gitâ€™s automatic merging vs. always doing merges manually?
A: Automatic merging is much more convenient than manual merging, allowing much easier collaboration with others. However, there is also the possibility that merges don't work, e.g. if a conflict exists but isn't detected by the automation. E.g., some code may change assumptions that my change relied on.
